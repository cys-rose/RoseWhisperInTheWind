import{_ as a,c as t,b as r,o as n}from"./app-UmRH3Hjg.js";const i={};function o(p,e){return n(),t("div",null,e[0]||(e[0]=[r('<h1 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h1><p>运行时数据区中有这五大区域：程序计数器、Java 虚拟机栈、本地方法栈、堆、方法区。（前三是线程私有的，后二是所有线程共用的）</p><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><p>为了线程切换后能恢复到正确的执行位置，每个线程都有自己的程序计数器。这个计数器记录的是正在执行虚拟机字节码指令的地址；如果正在执行 Native 方法，则程序计数器为空。同时这也是唯一不会出现 OOM 的区域。</p><h2 id="java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#java-虚拟机栈"><span>Java 虚拟机栈</span></a></h2><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法在执行时都会创建一个栈帧。如果线程请求的栈的深度大于 虚拟机栈的最大深度，则抛出 StackOverflowError 异常。当栈扩展时无法获得更大的内存时，会出现 OOM。</p><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h2><p>与虚拟机栈的作用相似，只是这个本地方法栈是为 Native 方法服务的。</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><p>几乎所有的对象实例都在堆中分配。但其实堆中内存并不是完全共享的，在 Eden 区中，每个线程都有自己的 TLAB（Thread Local Allocate Buffer）</p><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h2><p>存放被虚拟机加载的类型信息、常量、静态变量、JIT 编译后的代码缓存。</p>',12)]))}const c=a(i,[["render",o],["__file","runtime-data.html.vue"]]),s=JSON.parse('{"path":"/backendPro/jvm/runtime-data.html","title":"运行时数据区","lang":"zh-CN","frontmatter":{"description":"运行时数据区 运行时数据区中有这五大区域：程序计数器、Java 虚拟机栈、本地方法栈、堆、方法区。（前三是线程私有的，后二是所有线程共用的） 程序计数器 为了线程切换后能恢复到正确的执行位置，每个线程都有自己的程序计数器。这个计数器记录的是正在执行虚拟机字节码指令的地址；如果正在执行 Native 方法，则程序计数器为空。同时这也是唯一不会出现 OOM...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/backendPro/jvm/runtime-data.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"运行时数据区"}],["meta",{"property":"og:description","content":"运行时数据区 运行时数据区中有这五大区域：程序计数器、Java 虚拟机栈、本地方法栈、堆、方法区。（前三是线程私有的，后二是所有线程共用的） 程序计数器 为了线程切换后能恢复到正确的执行位置，每个线程都有自己的程序计数器。这个计数器记录的是正在执行虚拟机字节码指令的地址；如果正在执行 Native 方法，则程序计数器为空。同时这也是唯一不会出现 OOM..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-07T10:20:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-07T10:20:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"运行时数据区\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-07T10:20:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":2,"title":"Java 虚拟机栈","slug":"java-虚拟机栈","link":"#java-虚拟机栈","children":[]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":2,"title":"方法区","slug":"方法区","link":"#方法区","children":[]}],"git":{"createdTime":1736245252000,"updatedTime":1736245252000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":1.16,"words":349},"filePathRelative":"backendPro/jvm/runtime-data.md","localizedDate":"2025年1月7日","excerpt":"\\n<p>运行时数据区中有这五大区域：程序计数器、Java 虚拟机栈、本地方法栈、堆、方法区。（前三是线程私有的，后二是所有线程共用的）</p>\\n<h2>程序计数器</h2>\\n<p>为了线程切换后能恢复到正确的执行位置，每个线程都有自己的程序计数器。这个计数器记录的是正在执行虚拟机字节码指令的地址；如果正在执行 Native 方法，则程序计数器为空。同时这也是唯一不会出现 OOM 的区域。</p>\\n<h2>Java 虚拟机栈</h2>\\n<p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法在执行时都会创建一个栈帧。如果线程请求的栈的深度大于 虚拟机栈的最大深度，则抛出 StackOverflowError 异常。当栈扩展时无法获得更大的内存时，会出现 OOM。</p>","autoDesc":true}');export{c as comp,s as data};
