import{_ as t,c as i,b as n,o as a}from"./app-cDeSiteD.js";const o="/RoseWhisperInTheWind/assets/%E5%B9%82%E7%AD%89%E6%80%A7-D7MxBIep.png",r={};function l(p,e){return a(),i("div",null,e[0]||(e[0]=[n('<h1 id="什么是幂等性" tabindex="-1"><a class="header-anchor" href="#什么是幂等性"><span>什么是幂等性</span></a></h1><p>业务幂等性是说：用户的同一个请求，无论执行多少次，最后得到的结果应该是一致的。比如用户给一个商品下单，无论点击多少次，都应该只生成一个订单。如果不保证幂等性，多次点击后就会生成多个订单，是不是有点像解决并发问题？那我直接加一个分布式锁不就完事了？别急往下看！</p><h2 id="如何实现幂等性" tabindex="-1"><a class="header-anchor" href="#如何实现幂等性"><span>如何实现幂等性</span></a></h2><p><img src="'+o+'" alt="幂等" loading="lazy"> 上图中只做到了基本实现，但是还有两个问题：1.如果在删除 Redis 前后端服务器挂了怎么办？2.如果有恶意请求攻击怎么办？</p><ol><li>对于第一点，很简单。直接给 Redis 的 key-value 加上过期时间（大于生成订单需要的时间）</li><li>对于第二点，我们最好要在进入 Redis 前新加一层验证。我么可以使用非对称算法，前端用私钥加密 id 标识和下单的信息，由后端公钥解密，看看是否是 app 发来的还是恶意数据。</li></ol><h2 id="幂等问题和并发问题的区别" tabindex="-1"><a class="header-anchor" href="#幂等问题和并发问题的区别"><span>幂等问题和并发问题的区别</span></a></h2><ol><li>幂等性：是同一个人发来的请求，而且这些请求只能执行一次，其他的相同请求要放弃处理。</li><li>并发问题（锁）：多个人发来的请求，没有获得到锁的等待，获得到锁的继续接着执行处理。</li></ol>',7)]))}const d=t(r,[["render",l],["__file","mideng.html.vue"]]),c=JSON.parse('{"path":"/anything/mideng.html","title":"什么是幂等性","lang":"zh-CN","frontmatter":{"description":"什么是幂等性 业务幂等性是说：用户的同一个请求，无论执行多少次，最后得到的结果应该是一致的。比如用户给一个商品下单，无论点击多少次，都应该只生成一个订单。如果不保证幂等性，多次点击后就会生成多个订单，是不是有点像解决并发问题？那我直接加一个分布式锁不就完事了？别急往下看！ 如何实现幂等性 幂等 上图中只做到了基本实现，但是还有两个问题：1.如果在删除 ...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/anything/mideng.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"什么是幂等性"}],["meta",{"property":"og:description","content":"什么是幂等性 业务幂等性是说：用户的同一个请求，无论执行多少次，最后得到的结果应该是一致的。比如用户给一个商品下单，无论点击多少次，都应该只生成一个订单。如果不保证幂等性，多次点击后就会生成多个订单，是不是有点像解决并发问题？那我直接加一个分布式锁不就完事了？别急往下看！ 如何实现幂等性 幂等 上图中只做到了基本实现，但是还有两个问题：1.如果在删除 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-11T13:55:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-11T13:55:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是幂等性\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-11T13:55:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"如何实现幂等性","slug":"如何实现幂等性","link":"#如何实现幂等性","children":[]},{"level":2,"title":"幂等问题和并发问题的区别","slug":"幂等问题和并发问题的区别","link":"#幂等问题和并发问题的区别","children":[]}],"git":{"createdTime":1736603734000,"updatedTime":1736603734000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":1.26,"words":377},"filePathRelative":"anything/mideng.md","localizedDate":"2025年1月11日","excerpt":"\\n<p>业务幂等性是说：用户的同一个请求，无论执行多少次，最后得到的结果应该是一致的。比如用户给一个商品下单，无论点击多少次，都应该只生成一个订单。如果不保证幂等性，多次点击后就会生成多个订单，是不是有点像解决并发问题？那我直接加一个分布式锁不就完事了？别急往下看！</p>\\n<h2>如何实现幂等性</h2>\\n<p>\\n上图中只做到了基本实现，但是还有两个问题：1.如果在删除 Redis 前后端服务器挂了怎么办？2.如果有恶意请求攻击怎么办？</p>\\n<ol>\\n<li>对于第一点，很简单。直接给 Redis 的 key-value 加上过期时间（大于生成订单需要的时间）</li>\\n<li>对于第二点，我们最好要在进入 Redis 前新加一层验证。我么可以使用非对称算法，前端用私钥加密 id 标识和下单的信息，由后端公钥解密，看看是否是 app 发来的还是恶意数据。</li>\\n</ol>","autoDesc":true}');export{d as comp,c as data};
