import{_ as t,c as r,b as o,o as n}from"./app-CUlMDguP.js";const a={};function d(p,e){return n(),r("div",null,e[0]||(e[0]=[o('<h1 id="如何解决订单相关问题" tabindex="-1"><a class="header-anchor" href="#如何解决订单相关问题"><span>如何解决订单相关问题？</span></a></h1><h2 id="重复提交订单" tabindex="-1"><a class="header-anchor" href="#重复提交订单"><span>重复提交订单</span></a></h2><p>使用分布式锁，在用户第一次提交订单时，就尝试获取分布式锁，key 不能简单的设置为 orderId，因为 orderId 通常都是用雪花算法生成的，第二次重复提交订单时，得到的 orderId 时不同的，但是我们可以使用 userId 和任何一些 xxx 你想要减小锁细度的东西。</p><h2 id="支付订单问题" tabindex="-1"><a class="header-anchor" href="#支付订单问题"><span>支付订单问题</span></a></h2><p>问题描述：当用户付款时，正好到了订单自动取消的时间。而用户付完款后，订单的状态确实超时取消。</p><p>个人想法：在点击支付的时候尝试设置分布式锁（使用 orderId），点击取消订单的时候也尝试设置分布式锁（与上面的是同一个 key）这样当你点击支付后，即使到期了也因为无法获得分布式锁而不会自动取消订单。</p>',6)]))}const s=t(a,[["render",d],["__file","jdshoppingQS.html.vue"]]),h=JSON.parse('{"path":"/anything/jdshoppingQS.html","title":"如何解决订单相关问题？","lang":"zh-CN","frontmatter":{"description":"如何解决订单相关问题？ 重复提交订单 使用分布式锁，在用户第一次提交订单时，就尝试获取分布式锁，key 不能简单的设置为 orderId，因为 orderId 通常都是用雪花算法生成的，第二次重复提交订单时，得到的 orderId 时不同的，但是我们可以使用 userId 和任何一些 xxx 你想要减小锁细度的东西。 支付订单问题 问题描述：当用户付款...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/anything/jdshoppingQS.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"如何解决订单相关问题？"}],["meta",{"property":"og:description","content":"如何解决订单相关问题？ 重复提交订单 使用分布式锁，在用户第一次提交订单时，就尝试获取分布式锁，key 不能简单的设置为 orderId，因为 orderId 通常都是用雪花算法生成的，第二次重复提交订单时，得到的 orderId 时不同的，但是我们可以使用 userId 和任何一些 xxx 你想要减小锁细度的东西。 支付订单问题 问题描述：当用户付款..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-30T08:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-30T08:18:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何解决订单相关问题？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-30T08:18:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"重复提交订单","slug":"重复提交订单","link":"#重复提交订单","children":[]},{"level":2,"title":"支付订单问题","slug":"支付订单问题","link":"#支付订单问题","children":[]}],"git":{"createdTime":1735131860000,"updatedTime":1735546698000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":0.81,"words":242},"filePathRelative":"anything/jdshoppingQS.md","localizedDate":"2024年12月25日","excerpt":"\\n<h2>重复提交订单</h2>\\n<p>使用分布式锁，在用户第一次提交订单时，就尝试获取分布式锁，key 不能简单的设置为 orderId，因为 orderId 通常都是用雪花算法生成的，第二次重复提交订单时，得到的 orderId 时不同的，但是我们可以使用 userId 和任何一些 xxx 你想要减小锁细度的东西。</p>\\n<h2>支付订单问题</h2>\\n<p>问题描述：当用户付款时，正好到了订单自动取消的时间。而用户付完款后，订单的状态确实超时取消。</p>\\n<p>个人想法：在点击支付的时候尝试设置分布式锁（使用 orderId），点击取消订单的时候也尝试设置分布式锁（与上面的是同一个 key）这样当你点击支付后，即使到期了也因为无法获得分布式锁而不会自动取消订单。</p>","autoDesc":true}');export{s as comp,h as data};
