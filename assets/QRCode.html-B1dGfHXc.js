import{_ as t,c as o,b as n,o as i}from"./app-UmRH3Hjg.js";const r={};function a(s,e){return i(),o("div",null,e[0]||(e[0]=[n('<h1 id="如何扫描二维码登录" tabindex="-1"><a class="header-anchor" href="#如何扫描二维码登录"><span>如何扫描二维码登录？</span></a></h1><h2 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤"><span>步骤</span></a></h2><p>生成二维码 -&gt; 扫描二维码 -&gt; 登录</p><ol><li><strong>生成二维码</strong>：请求登录页，你的请求到达服务器，服务器生成二维码图以及 其 ID，把这个 ID 保存到 Redis 中。然后返回给你二维码图和 ID（但其实生成二维码图前后端都可以做这件事）。这时你在你的电脑上就可以看见二维码吧，然后你就拿手机扫码呗。诶！在你掏手机的时候，电脑可一点没闲着。自从你的电脑拿到二维码 ID 可是一直用这个 ID 去访问服务器，查看这个二维码的状态。这里可以用长连接（websocket）也可以轮询。</li><li><strong>扫描二维码</strong>：有么有注意到你扫描前一定要保证你的手机 App 是已经登录的！当你扫描二维码时，会把你 App 端登录的用户 token 和二维码 ID 一起发给服务器。服务器验证 token 有效后，二维码的状态变化了（待确认），PC 端页面呈现待确认的界面。然后会生成一个临时 token 绑定到 Redis 的二维码 ID 中（保证这个 ID 只被使用一次）并把这个临时 token 返回你的手机 App。</li><li><strong>确认登录</strong>:当你手机点击确认登录后，带着临时 token 请求服务器，服务器校验你的请求后，修改二维码状态（已登录）执行登录逻辑，生成 PC token。然后删除 Redis 里的临时 token，新增用户信息和 PC token。当你的电脑监控到二维码状态改变了，服务端会将 PC token 返回给前端。后续的电脑前端请求就都携带这个 token 了。</li></ol><p>文字描述的有点抽象，请读者拿根笔画画草图就能更容易理解了。我真是太懒得画图了。</p>',5)]))}const l=t(r,[["render",a],["__file","QRCode.html.vue"]]),c=JSON.parse('{"path":"/anything/QRCode.html","title":"如何扫描二维码登录？","lang":"zh-CN","frontmatter":{"description":"如何扫描二维码登录？ 步骤 生成二维码 -> 扫描二维码 -> 登录 生成二维码：请求登录页，你的请求到达服务器，服务器生成二维码图以及 其 ID，把这个 ID 保存到 Redis 中。然后返回给你二维码图和 ID（但其实生成二维码图前后端都可以做这件事）。这时你在你的电脑上就可以看见二维码吧，然后你就拿手机扫码呗。诶！在你掏手机的时候，电脑可一点没闲...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/anything/QRCode.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"如何扫描二维码登录？"}],["meta",{"property":"og:description","content":"如何扫描二维码登录？ 步骤 生成二维码 -> 扫描二维码 -> 登录 生成二维码：请求登录页，你的请求到达服务器，服务器生成二维码图以及 其 ID，把这个 ID 保存到 Redis 中。然后返回给你二维码图和 ID（但其实生成二维码图前后端都可以做这件事）。这时你在你的电脑上就可以看见二维码吧，然后你就拿手机扫码呗。诶！在你掏手机的时候，电脑可一点没闲..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-30T08:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-30T08:18:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何扫描二维码登录？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-30T08:18:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"步骤","slug":"步骤","link":"#步骤","children":[]}],"git":{"createdTime":1734091235000,"updatedTime":1735546698000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":1.63,"words":488},"filePathRelative":"anything/QRCode.md","localizedDate":"2024年12月13日","excerpt":"\\n<h2>步骤</h2>\\n<p>生成二维码 -&gt; 扫描二维码 -&gt; 登录</p>\\n<ol>\\n<li><strong>生成二维码</strong>：请求登录页，你的请求到达服务器，服务器生成二维码图以及 其 ID，把这个 ID 保存到 Redis 中。然后返回给你二维码图和 ID（但其实生成二维码图前后端都可以做这件事）。这时你在你的电脑上就可以看见二维码吧，然后你就拿手机扫码呗。诶！在你掏手机的时候，电脑可一点没闲着。自从你的电脑拿到二维码 ID 可是一直用这个 ID 去访问服务器，查看这个二维码的状态。这里可以用长连接（websocket）也可以轮询。</li>\\n<li><strong>扫描二维码</strong>：有么有注意到你扫描前一定要保证你的手机 App 是已经登录的！当你扫描二维码时，会把你 App 端登录的用户 token 和二维码 ID 一起发给服务器。服务器验证 token 有效后，二维码的状态变化了（待确认），PC 端页面呈现待确认的界面。然后会生成一个临时 token 绑定到 Redis 的二维码 ID 中（保证这个 ID 只被使用一次）并把这个临时 token 返回你的手机 App。</li>\\n<li><strong>确认登录</strong>:当你手机点击确认登录后，带着临时 token 请求服务器，服务器校验你的请求后，修改二维码状态（已登录）执行登录逻辑，生成 PC token。然后删除 Redis 里的临时 token，新增用户信息和 PC token。当你的电脑监控到二维码状态改变了，服务端会将 PC token 返回给前端。后续的电脑前端请求就都携带这个 token 了。</li>\\n</ol>","autoDesc":true}');export{l as comp,c as data};
