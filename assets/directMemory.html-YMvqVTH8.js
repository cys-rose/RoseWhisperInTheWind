import{_ as t,c as o,b as a,o as r}from"./app-DFDql4E9.js";const c={};function i(l,e){return r(),o("div",null,e[0]||(e[0]=[a('<h1 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存"><span>直接内存</span></a></h1><p>直接内存是位于 JVM 堆外的一块内存，其大小是由 -XX:MaxDirectMemorySize 参数来控制的。并且直接内存不由 GC 所控制。</p><h2 id="用途" tabindex="-1"><a class="header-anchor" href="#用途"><span>用途</span></a></h2><ol><li>提高性能： 对于某些 I/O 密集型的应用，比如网络通信和文件 I/O 操作，使用直接内存可以减少数据在 Java 堆和操作系统之间的复制次数，从而提升性能。例如，在进行网络传输时，数据可以从网卡直接写入到直接内存中，然后由应用程序读取，而不必先将数据复制到 Java 堆中。</li><li>与本地方法联合使用： 当我们调用本地方法时，会通过<code>java.nio.ByteBuffer.allocateDirect</code>在直接内存中开辟一块内存空间，然后由<code>DirectByteBuffer</code>的地址返回给本地方法，这样就可以减少数据在 Java 堆和本地方法之间的复制。</li></ol><h2 id="如何释放内存" tabindex="-1"><a class="header-anchor" href="#如何释放内存"><span>如何释放内存？</span></a></h2><p>因为直接内存在堆外，不受 GC 管理，那么到底是如何释放内存的呢？</p><ol><li>引用计数算法： <ol><li>当使用<code>allocateDirect</code>方法分配直接内存时，JVM 会创建一个<code>DirectByteBuffer</code>来管理这个区域，也就是说<code>DirectByteBuffer</code>持有直接内存的一个指针。</li><li>如果堆中没有对<code>DirectByteBuffer</code>的引用，就会使其变成可被 GC 的对象。</li></ol></li><li>Cleaner <ol><li>每个<code>DirectByteBuffer</code>都关联了一个<code>Cleaner</code>对象，当<code>DirectByteBuffer</code>被回收的时候<code>Cleaner</code>就会被激活。这个<code>Cleaner</code>会被放到一个队列中。然后，一个守护线程会定期检查这个队列，并调用 Cleaner 的 clean 方法来释放直接内存。</li></ol></li><li>手动显示释放 调用<code>java.nio.ByteBuffer#cleaner().clean()</code>方法，但是有可能会导致释放掉还正在使用的内存，所以要谨慎使用。</li></ol>',7)]))}const d=t(c,[["render",i],["__file","directMemory.html.vue"]]),p=JSON.parse('{"path":"/backendPro/jvm/directMemory.html","title":"直接内存","lang":"zh-CN","frontmatter":{"description":"直接内存 直接内存是位于 JVM 堆外的一块内存，其大小是由 -XX:MaxDirectMemorySize 参数来控制的。并且直接内存不由 GC 所控制。 用途 提高性能： 对于某些 I/O 密集型的应用，比如网络通信和文件 I/O 操作，使用直接内存可以减少数据在 Java 堆和操作系统之间的复制次数，从而提升性能。例如，在进行网络传输时，数据可以...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/backendPro/jvm/directMemory.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"直接内存"}],["meta",{"property":"og:description","content":"直接内存 直接内存是位于 JVM 堆外的一块内存，其大小是由 -XX:MaxDirectMemorySize 参数来控制的。并且直接内存不由 GC 所控制。 用途 提高性能： 对于某些 I/O 密集型的应用，比如网络通信和文件 I/O 操作，使用直接内存可以减少数据在 Java 堆和操作系统之间的复制次数，从而提升性能。例如，在进行网络传输时，数据可以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-30T08:18:18.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-30T08:18:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"直接内存\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-30T08:18:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"用途","slug":"用途","link":"#用途","children":[]},{"level":2,"title":"如何释放内存？","slug":"如何释放内存","link":"#如何释放内存","children":[]}],"git":{"createdTime":1735131860000,"updatedTime":1735546698000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":1.5,"words":451},"filePathRelative":"backendPro/jvm/directMemory.md","localizedDate":"2024年12月25日","excerpt":"\\n<p>直接内存是位于 JVM 堆外的一块内存，其大小是由 -XX:MaxDirectMemorySize 参数来控制的。并且直接内存不由 GC 所控制。</p>\\n<h2>用途</h2>\\n<ol>\\n<li>提高性能：\\n对于某些 I/O 密集型的应用，比如网络通信和文件 I/O 操作，使用直接内存可以减少数据在 Java 堆和操作系统之间的复制次数，从而提升性能。例如，在进行网络传输时，数据可以从网卡直接写入到直接内存中，然后由应用程序读取，而不必先将数据复制到 Java 堆中。</li>\\n<li>与本地方法联合使用：\\n当我们调用本地方法时，会通过<code>java.nio.ByteBuffer.allocateDirect</code>在直接内存中开辟一块内存空间，然后由<code>DirectByteBuffer</code>的地址返回给本地方法，这样就可以减少数据在 Java 堆和本地方法之间的复制。</li>\\n</ol>","autoDesc":true}');export{d as comp,p as data};
