import{_ as s,c as i,b as n,o as a}from"./app-DeaA2L2o.js";const t={};function d(r,e){return a(),i("div",null,e[0]||(e[0]=[n(`<h1 id="redis-事务" tabindex="-1"><a class="header-anchor" href="#redis-事务"><span>Redis 事务</span></a></h1><p>Redis 事务不同于关系型数据库（如 MySQL）的事务。Redis 事务不能保证原子性，也许可以达到保证持久性的要求。为什么这么说？</p><h2 id="原子性-持久性" tabindex="-1"><a class="header-anchor" href="#原子性-持久性"><span>原子性？持久性？</span></a></h2><ol><li>关于原子性问题：一用“MULTI”开启了一个事务，然后写了很多 Redis 命令，然后“EXEC”提交事务。这其中的很多命令里，可以正确执行的就正确执行，出错的就在那错着，反正也不管，然后还不回滚。</li><li>关于持久性问题：首先我们要了解一下 Redis 的持久化机制，有三点 RDB、AOF 和 RDB 与 AOF 的混合持久化。 -RDB 持久化方式的实时性没有那么好，Redis 挂了容易丢失数据。 -AOF 相比会更加保险一些，但 AOF 也不一定保证数据持久性，因为 AOF 会在每次执行更改 Redis 数据的命令时，会将该命令写到 AOF 缓冲区中。而这也就是问题所在，因为有不同的 AOF 文件刷盘策略（fsync 策略）其分别是：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>appendfsync always    #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span></span>
<span class="line"><span>appendfsync everysec  #每秒钟调用fsync函数同步一次AOF文件</span></span>
<span class="line"><span>appendfsync no        #让操作系统决定何时进行同步，一般为30秒一次</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>所以说只有我们把 fsync 策略设置成 always，才可以满足事务的持久性。</li></ol><h2 id="redis-事务有什么用" tabindex="-1"><a class="header-anchor" href="#redis-事务有什么用"><span>Redis 事务有什么用？</span></a></h2><p>由于 Redis 执行命令是采用单线程的，所以当有多个客户端都在使用这个 Redis 服务端。那么就有可能某个 Redis 客户端执行一套命令时，其中被其他客户端插入了其他命令，可能会对这一套命令的结果产生影响。所以用 Redis 事务可以保证事务中的所有命令就是按照这个顺序执行的，中间不会被其他客户端插入命令。</p>`,6)]))}const p=s(t,[["render",d],["__file","redisTs.html.vue"]]),c=JSON.parse('{"path":"/backend/redis/redisTs.html","title":"Redis 事务","lang":"zh-CN","frontmatter":{"description":"Redis 事务 Redis 事务不同于关系型数据库（如 MySQL）的事务。Redis 事务不能保证原子性，也许可以达到保证持久性的要求。为什么这么说？ 原子性？持久性？ 关于原子性问题：一用“MULTI”开启了一个事务，然后写了很多 Redis 命令，然后“EXEC”提交事务。这其中的很多命令里，可以正确执行的就正确执行，出错的就在那错着，反正也不...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/backend/redis/redisTs.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"Redis 事务"}],["meta",{"property":"og:description","content":"Redis 事务 Redis 事务不同于关系型数据库（如 MySQL）的事务。Redis 事务不能保证原子性，也许可以达到保证持久性的要求。为什么这么说？ 原子性？持久性？ 关于原子性问题：一用“MULTI”开启了一个事务，然后写了很多 Redis 命令，然后“EXEC”提交事务。这其中的很多命令里，可以正确执行的就正确执行，出错的就在那错着，反正也不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-25T13:04:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-25T13:04:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 事务\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-25T13:04:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"原子性？持久性？","slug":"原子性-持久性","link":"#原子性-持久性","children":[]},{"level":2,"title":"Redis 事务有什么用？","slug":"redis-事务有什么用","link":"#redis-事务有什么用","children":[]}],"git":{"createdTime":1735131860000,"updatedTime":1735131860000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":1.72,"words":516},"filePathRelative":"backend/redis/redisTs.md","localizedDate":"2024年12月25日","excerpt":"\\n<p>Redis 事务不同于关系型数据库（如 MySQL）的事务。Redis 事务不能保证原子性，也许可以达到保证持久性的要求。为什么这么说？</p>\\n<h2>原子性？持久性？</h2>\\n<ol>\\n<li>关于原子性问题：一用“MULTI”开启了一个事务，然后写了很多 Redis 命令，然后“EXEC”提交事务。这其中的很多命令里，可以正确执行的就正确执行，出错的就在那错着，反正也不管，然后还不回滚。</li>\\n<li>关于持久性问题：首先我们要了解一下 Redis 的持久化机制，有三点 RDB、AOF 和 RDB 与 AOF 的混合持久化。\\n-RDB 持久化方式的实时性没有那么好，Redis 挂了容易丢失数据。\\n-AOF 相比会更加保险一些，但 AOF 也不一定保证数据持久性，因为 AOF 会在每次执行更改 Redis 数据的命令时，会将该命令写到 AOF 缓冲区中。而这也就是问题所在，因为有不同的 AOF 文件刷盘策略（fsync 策略）其分别是：<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>appendfsync always    #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span></span>\\n<span class=\\"line\\"><span>appendfsync everysec  #每秒钟调用fsync函数同步一次AOF文件</span></span>\\n<span class=\\"line\\"><span>appendfsync no        #让操作系统决定何时进行同步，一般为30秒一次</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>所以说只有我们把 fsync 策略设置成 always，才可以满足事务的持久性。</li>\\n</ol>","autoDesc":true}');export{p as comp,c as data};
