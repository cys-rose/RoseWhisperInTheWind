import{_ as t,c as n,b as i,o as l}from"./app-CUlMDguP.js";const o="/RoseWhisperInTheWind/assets/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4-DPiM9os_.png",a="/RoseWhisperInTheWind/assets/canal%E8%AE%A2%E9%98%85binlog-DL1pb4on.png",s={};function r(p,e){return l(),n("div",null,e[0]||(e[0]=[i('<h1 id="缓存与数据库的一致性" tabindex="-1"><a class="header-anchor" href="#缓存与数据库的一致性"><span>缓存与数据库的一致性</span></a></h1><p>这个问题很常见，而且也有一个比较适合的解决方案，但肯定不能保证百分百一致，只是不一致的现象很难发生。不卖关子了，也不说其他方案有什么不好了，我直接给你讲为什么要用这个方案吧。那就是<strong>先更新数据库，后删除缓存</strong>。（本篇学自<code>水滴与银弹</code>微信公众号文章）</p><h2 id="先更新数据库-后删除缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库-后删除缓存"><span>先更新数据库，后删除缓存</span></a></h2><ol><li><p>出错情况：这种情况可能会出现不一致，但是概率非常低。</p><ol><li>缓存中 A 不存在（数据库中 A = 1）</li><li>线程 1 读取数据库，得到旧值（A = 1）</li><li>线程 2 更新数据库（A = 2）</li><li>线程 2 删除缓存 A</li><li>线程 1 把读到的旧 A 写入缓存</li></ol></li><li><p>为什么概率低？ 它必须满足以下的条件：</p><ol><li>缓存恰好过期</li><li>读请求和写请求并发执行</li><li>上面线程 2 花费的时间比线程 1 花费的少（线程 2 先于线程 1 执行完）但是一般写入数据库（MySQL）你肯定是要加锁的，表锁或行锁，那么花费的时间通常是比读数据库操作的长。</li></ol></li><li><p>如何保证更新完数据库后，删除缓存操作一定成功？ 就是你了**<em>重试</em><strong>。但是要考虑好重试次数，如果一直重试会一直占用这个线程资源。那么怎么办才好啊？就是你了</strong><em>异步重试</em>**：其实就是把重试请求写到消息队列中，然后由专门的消费者来重试，直到成功。那你又加了一个消息队列，不是让业务更复杂了吗？嗯是这样的，但是消息队列的好处也是大大的，除了上面的功能外，如果执行删除缓存的线程在重试过程中，突然后端服务挂了，那么重试请求也停止了（丢失了）导致数据库和缓存中的数据不一致了，而把这个删除缓存的请求放到消息队列中，等你重启后，还可以继续消费。 <img src="'+o+'" alt="先修改数据库后删缓存" loading="lazy"></p></li><li><p>除了消息队列，现在比较流行的是<strong>订阅数据库变更日志，再操作缓存</strong>。如当 MySQL 修改数据后，会在 Binlog 中记录一条日志，然后通过订阅这个日志，再删除对应的缓存。 <img src="'+a+'" alt="订阅数据库日志" loading="lazy"> 这样就不用考虑后端写入消息队列时失败的情况了。</p></li></ol><h2 id="介绍延迟双删" tabindex="-1"><a class="header-anchor" href="#介绍延迟双删"><span>介绍延迟双删</span></a></h2><ol><li>在<strong>先删除缓存后更新数据库</strong>时可以使用延时双删：在某个线程删除缓存、更新完数据库之后，先“休眠一会”，再“删除”一次缓存。</li><li>在数据库使用了主从架构时，因为在<strong>先更新数据库后删除缓存</strong>的情况下，使用了主从，在修改完主数据库后删完缓存后还没来的及更新从数据库时，有一个新的请求来访问数据（肯定是去从数据库），得到旧值，又写入缓存（旧值），从而·导致数据不一致。该怎么办？ <ol><li>也是延迟双删的思想。当主数据库更新完后，写入消息队列中一条延迟消息（用于删除缓存）时间就设置在差不多从数据库更新完后的大小。</li></ol></li></ol>',6)]))}const d=t(s,[["render",r],["__file","dataConsistance.html.vue"]]),m=JSON.parse('{"path":"/backend/redis/dataConsistance.html","title":"缓存与数据库的一致性","lang":"zh-CN","frontmatter":{"description":"缓存与数据库的一致性 这个问题很常见，而且也有一个比较适合的解决方案，但肯定不能保证百分百一致，只是不一致的现象很难发生。不卖关子了，也不说其他方案有什么不好了，我直接给你讲为什么要用这个方案吧。那就是先更新数据库，后删除缓存。（本篇学自水滴与银弹微信公众号文章） 先更新数据库，后删除缓存 出错情况：这种情况可能会出现不一致，但是概率非常低。 缓存中 ...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/RoseWhisperInTheWind/backend/redis/dataConsistance.html"}],["meta",{"property":"og:site_name","content":"风中玫瑰的低语"}],["meta",{"property":"og:title","content":"缓存与数据库的一致性"}],["meta",{"property":"og:description","content":"缓存与数据库的一致性 这个问题很常见，而且也有一个比较适合的解决方案，但肯定不能保证百分百一致，只是不一致的现象很难发生。不卖关子了，也不说其他方案有什么不好了，我直接给你讲为什么要用这个方案吧。那就是先更新数据库，后删除缓存。（本篇学自水滴与银弹微信公众号文章） 先更新数据库，后删除缓存 出错情况：这种情况可能会出现不一致，但是概率非常低。 缓存中 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-25T13:04:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-25T13:04:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"缓存与数据库的一致性\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-25T13:04:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Rose\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"先更新数据库，后删除缓存","slug":"先更新数据库-后删除缓存","link":"#先更新数据库-后删除缓存","children":[]},{"level":2,"title":"介绍延迟双删","slug":"介绍延迟双删","link":"#介绍延迟双删","children":[]}],"git":{"createdTime":1735131860000,"updatedTime":1735131860000,"contributors":[{"name":"Rose","email":"2677596161@qq.com","commits":1}]},"readingTime":{"minutes":3.02,"words":905},"filePathRelative":"backend/redis/dataConsistance.md","localizedDate":"2024年12月25日","excerpt":"\\n<p>这个问题很常见，而且也有一个比较适合的解决方案，但肯定不能保证百分百一致，只是不一致的现象很难发生。不卖关子了，也不说其他方案有什么不好了，我直接给你讲为什么要用这个方案吧。那就是<strong>先更新数据库，后删除缓存</strong>。（本篇学自<code>水滴与银弹</code>微信公众号文章）</p>\\n<h2>先更新数据库，后删除缓存</h2>\\n<ol>\\n<li>\\n<p>出错情况：这种情况可能会出现不一致，但是概率非常低。</p>\\n<ol>\\n<li>缓存中 A 不存在（数据库中 A = 1）</li>\\n<li>线程 1 读取数据库，得到旧值（A = 1）</li>\\n<li>线程 2 更新数据库（A = 2）</li>\\n<li>线程 2 删除缓存 A</li>\\n<li>线程 1 把读到的旧 A 写入缓存</li>\\n</ol>\\n</li>\\n<li>\\n<p>为什么概率低？\\n它必须满足以下的条件：</p>\\n<ol>\\n<li>缓存恰好过期</li>\\n<li>读请求和写请求并发执行</li>\\n<li>上面线程 2 花费的时间比线程 1 花费的少（线程 2 先于线程 1 执行完）但是一般写入数据库（MySQL）你肯定是要加锁的，表锁或行锁，那么花费的时间通常是比读数据库操作的长。</li>\\n</ol>\\n</li>\\n<li>\\n<p>如何保证更新完数据库后，删除缓存操作一定成功？\\n就是你了**<em>重试</em><strong>。但是要考虑好重试次数，如果一直重试会一直占用这个线程资源。那么怎么办才好啊？就是你了</strong><em>异步重试</em>**：其实就是把重试请求写到消息队列中，然后由专门的消费者来重试，直到成功。那你又加了一个消息队列，不是让业务更复杂了吗？嗯是这样的，但是消息队列的好处也是大大的，除了上面的功能外，如果执行删除缓存的线程在重试过程中，突然后端服务挂了，那么重试请求也停止了（丢失了）导致数据库和缓存中的数据不一致了，而把这个删除缓存的请求放到消息队列中，等你重启后，还可以继续消费。\\n</p>\\n</li>\\n<li>\\n<p>除了消息队列，现在比较流行的是<strong>订阅数据库变更日志，再操作缓存</strong>。如当 MySQL 修改数据后，会在 Binlog 中记录一条日志，然后通过订阅这个日志，再删除对应的缓存。\\n\\n这样就不用考虑后端写入消息队列时失败的情况了。</p>\\n</li>\\n</ol>","autoDesc":true}');export{d as comp,m as data};
