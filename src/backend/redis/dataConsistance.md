# 缓存与数据库的一致性

这个问题很常见，而且也有一个比较适合的解决方案，但肯定不能保证百分百一致，只是不一致的现象很难发生。不卖关子了，也不说其他方案有什么不好了，我直接给你讲为什么要用这个方案吧。那就是**先更新数据库，后删除缓存**。（本篇学自`水滴与银弹`微信公众号文章）

## 先更新数据库，后删除缓存

1. 出错情况：这种情况可能会出现不一致，但是概率非常低。
   1. 缓存中 A 不存在（数据库中 A = 1）
   2. 线程 1 读取数据库，得到旧值（A = 1）
   3. 线程 2 更新数据库（A = 2）
   4. 线程 2 删除缓存 A
   5. 线程 1 把读到的旧 A 写入缓存
2. 为什么概率低？
   它必须满足以下的条件：
   1. 缓存恰好过期
   2. 读请求和写请求并发执行
   3. 上面线程 2 花费的时间比线程 1 花费的少（线程 2 先于线程 1 执行完）但是一般写入数据库（MySQL）你肯定是要加锁的，表锁或行锁，那么花费的时间通常是比读数据库操作的长。
3. 如何保证更新完数据库后，删除缓存操作一定成功？
   就是你了**_重试_**。但是要考虑好重试次数，如果一直重试会一直占用这个线程资源。那么怎么办才好啊？就是你了**_异步重试_**：其实就是把重试请求写到消息队列中，然后由专门的消费者来重试，直到成功。那你又加了一个消息队列，不是让业务更复杂了吗？嗯是这样的，但是消息队列的好处也是大大的，除了上面的功能外，如果执行删除缓存的线程在重试过程中，突然后端服务挂了，那么重试请求也停止了（丢失了）导致数据库和缓存中的数据不一致了，而把这个删除缓存的请求放到消息队列中，等你重启后，还可以继续消费。
   ![先修改数据库后删缓存](./image/缓存数据库数据一致.png)

4. 除了消息队列，现在比较流行的是**订阅数据库变更日志，再操作缓存**。如当 MySQL 修改数据后，会在 Binlog 中记录一条日志，然后通过订阅这个日志，再删除对应的缓存。
   ![订阅数据库日志](./image/canal订阅binlog.png)
   这样就不用考虑后端写入消息队列时失败的情况了。

## 介绍延迟双删

1. 在**先删除缓存后更新数据库**时可以使用延时双删：在某个线程删除缓存、更新完数据库之后，先“休眠一会”，再“删除”一次缓存。
2. 在数据库使用了主从架构时，因为在**先更新数据库后删除缓存**的情况下，使用了主从，在修改完主数据库后删完缓存后还没来的及更新从数据库时，有一个新的请求来访问数据（肯定是去从数据库），得到旧值，又写入缓存（旧值），从而·导致数据不一致。该怎么办？
   1. 也是延迟双删的思想。当主数据库更新完后，写入消息队列中一条延迟消息（用于删除缓存）时间就设置在差不多从数据库更新完后的大小。
