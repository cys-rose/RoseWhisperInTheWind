# 所有的锁

## 悲观锁与乐观锁

1. 悲观锁：认为共享资源在每次被访问的时候都会出现问题（如被其他线程修改），所以每次使用这个共享资源时都加锁，使用完后再释放锁。
2. 乐观锁：认为共享资源在每次被访问的时候都不会（很少）出现问题，所以每次使用这个共享资源时只是去验证这个数据有没有被其他线程修改。（CAS）

ps：乐观锁不适合在并发量大的场景中使用，大量线程不断 CAS 极大可能 CAS 失败，而一直重试使得性能下降。

## 公平锁与非公平锁

1. 公平锁：每次获取锁的线程都是按照队列的顺序来获取锁的。当前线程需要放到阻塞队列中等待。
2. 非公平锁：每次获取锁时当前线程有可能直接获取到锁。

## 可中断锁与不可中断锁

1. 可中断锁：允许线程在等待锁的过程中响应中断请求。如果线程在等待锁时被中断，它会抛出 InterruptedException 并停止等待。
   适用于需要及时取消任务的场景。
2. 不可中断锁：在等待锁时不会响应中断请求，线程会一直等待直到获取锁。
   适用于有必须要完成的关键任务，这个任务必须完成不能中途取消。

## 共享锁与独占锁

1. 共享锁（读锁）：一个锁可被多个线程占有。只用于读不能修改。当有一个线程占用共享锁时，其他线程不同获取排他锁。
   适用于读多写少的场景。
2. 排他锁（写锁）：一个锁只能被一个线程占有。与共享锁互斥。
   适用于写操作多的场景。
